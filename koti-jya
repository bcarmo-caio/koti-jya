#!/usr/bin/env python3

#TODO fix program when stop_condition = f and num_threads = 1
#TODO fix f mode, the difference should be between the cosine from last iteration and current cosine, not between terms
#TODO debug, thread order printing is correct?
#TODO Compile?
#TODO Report...

import sys
import threading
import multiprocessing
import mpmath
import multiprocessing

def calculate_next_taylor_term(i):
    n = num_threads*num_iterations + i
    term[i] = (-1)**n/mpmath.factorial(2*n)*x**(2*n) #TODO must check mpmath.factorial implementation


def thread(i):
    while True:
        calculate_next_taylor_term(i)
        if debug: print("Thread " + str(i) + " arrived at the barrier")
        barrier1.wait()
        barrier2.wait()
        if kill_threads: return


def main():
    global num_threads, num_iterations, term, x, cosine, option, debug, barrier1, barrier2, kill_threads

    # Setting precision (number of decimal places)
    mpmath.mp.dps = 100 #TODO change to 100000

    # Initialization
    if len(sys.argv) < 5:
        print("Usage: " + sys.argv[0] + " num_threads f|m precision x [d|s]")
        exit(1)
    num_iterations = mpmath.mpf(0)
    cosine = mpmath.mpf(0)
    stop_condition = sys.argv[2]
    precision = 10**(-1*mpmath.mpf(sys.argv[3]))
    x = mpmath.mpf(sys.argv[4])
    try:
        option = sys.argv[5]
    except:
        option = None
    if option == "s":
        parallel = False
        num_threads = 1
        debug = True
    else:
        parallel = True
        num_threads = int(sys.argv[1]) or multiprocessing.cpu_count()
        if option == "d": debug = True
        else: debug = False
    term = [0] * num_threads
    if parallel:
        barrier1 = threading.Barrier(num_threads + 1)
        barrier2 = threading.Barrier(num_threads + 1)
        kill_threads = False

    if parallel:
        threads = []
        for i in range(num_threads):
            t = threading.Thread(target=thread, args=(i,))
            threads.append(t)
            t.start()
    while True:
        if parallel:
            barrier1.wait()
        else:
            calculate_next_taylor_term(0)
        num_iterations += 1
        for i in range(num_threads):
            cosine += term[i]
            # If stop condition is reached print result and terminate
            if (stop_condition == "f" and mpmath.fabs(term[i - 1] - term[i]) < precision) or (stop_condition == "m" and mpmath.fabs(term[i]) < precision):
                if debug: print()
                if option == "s":
                    print("Number of terms calculated: ", end='')
                else:
                    print("Number of rounds: ", end='')
                print(str(int(num_iterations)))
                print("cos(" + str(x) + ") = " + str(cosine))
                if parallel:
                    kill_threads = True
                    barrier2.wait()
                return
        if debug:
            print("Partial value for cos(" + str(x) + ") in iteration " + str(int(num_iterations)) + ": " + str(cosine))
        if parallel: barrier2.wait()


if __name__ == '__main__':
    main()
